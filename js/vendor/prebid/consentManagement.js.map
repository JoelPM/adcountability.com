{"version":3,"file":"consentManagement.js","mappings":"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","sources":["webpack://prebid.js/./modules/consentManagement.js"],"sourcesContent":["/**\n * This module adds GDPR consentManagement support to prebid.js.  It interacts with\n * supported CMPs (Consent Management Platforms) to grab the user's consent information\n * and make it available for any GDPR supported adapters to read/pass this information to\n * their system.\n */\nimport {getAdUnitSizes, isFn, isNumber, isPlainObject, isStr, logError, logInfo, logWarn} from '../src/utils.js';\nimport {config} from '../src/config.js';\nimport {gdprDataHandler} from '../src/adapterManager.js';\nimport {includes} from '../src/polyfill.js';\n\nconst DEFAULT_CMP = 'iab';\nconst DEFAULT_CONSENT_TIMEOUT = 10000;\nconst DEFAULT_ALLOW_AUCTION_WO_CONSENT = true;\n\nexport const allowAuction = {\n  value: DEFAULT_ALLOW_AUCTION_WO_CONSENT,\n  definedInConfig: false\n}\nexport let userCMP;\nexport let consentTimeout;\nexport let gdprScope;\nexport let staticConsentData;\n\nlet cmpVersion = 0;\nlet consentData;\nlet addedConsentHook = false;\n\n// add new CMPs here, with their dedicated lookup function\nconst cmpCallMap = {\n  'iab': lookupIabConsent,\n  'static': lookupStaticConsentData\n};\n\n/**\n * This function reads the consent string from the config to obtain the consent information of the user.\n * @param {function({})} onSuccess acts as a success callback when the value is read from config; pass along consentObject from CMP\n */\nfunction lookupStaticConsentData({onSuccess}) {\n  onSuccess(staticConsentData);\n}\n\n/**\n * This function handles interacting with an IAB compliant CMP to obtain the consent information of the user.\n * Given the async nature of the CMP's API, we pass in acting success/error callback functions to exit this function\n * based on the appropriate result.\n * @param {function({})} onSuccess acts as a success callback when CMP returns a value; pass along consentObjectfrom CMP\n * @param {function(string, ...{}?)} cmpError acts as an error callback while interacting with CMP; pass along an error message (string) and any extra error arguments (purely for logging)\n * @param width\n * @param height size info passed to the SafeFrame API (used only for TCFv1 when Prebid is running within a safeframe)\n */\nfunction lookupIabConsent({onSuccess, onError, width, height}) {\n  function findCMP() {\n    let f = window;\n    let cmpFrame;\n    let cmpFunction;\n    while (!cmpFrame) {\n      try {\n        if (typeof f.__tcfapi === 'function' || typeof f.__cmp === 'function') {\n          if (typeof f.__tcfapi === 'function') {\n            cmpVersion = 2;\n            cmpFunction = f.__tcfapi;\n          } else {\n            cmpVersion = 1;\n            cmpFunction = f.__cmp;\n          }\n          cmpFrame = f;\n          break;\n        }\n      } catch (e) { }\n\n      // need separate try/catch blocks due to the exception errors thrown when trying to check for a frame that doesn't exist in 3rd party env\n      try {\n        if (f.frames['__tcfapiLocator']) {\n          cmpVersion = 2;\n          cmpFrame = f;\n          break;\n        }\n      } catch (e) { }\n\n      try {\n        if (f.frames['__cmpLocator']) {\n          cmpVersion = 1;\n          cmpFrame = f;\n          break;\n        }\n      } catch (e) { }\n\n      if (f === window.top) break;\n      f = f.parent;\n    }\n    return {\n      cmpFrame,\n      cmpFunction\n    };\n  }\n\n  function v2CmpResponseCallback(tcfData, success) {\n    logInfo('Received a response from CMP', tcfData);\n    if (success) {\n      if (tcfData.gdprApplies === false || tcfData.eventStatus === 'tcloaded' || tcfData.eventStatus === 'useractioncomplete') {\n        processCmpData(tcfData, {onSuccess, onError});\n      }\n    } else {\n      onError('CMP unable to register callback function.  Please check CMP setup.');\n    }\n  }\n\n  function handleV1CmpResponseCallbacks() {\n    const cmpResponse = {};\n\n    function afterEach() {\n      if (cmpResponse.getConsentData && cmpResponse.getVendorConsents) {\n        logInfo('Received all requested responses from CMP', cmpResponse);\n        processCmpData(cmpResponse, {onSuccess, onError});\n      }\n    }\n\n    return {\n      consentDataCallback: function (consentResponse) {\n        cmpResponse.getConsentData = consentResponse;\n        afterEach();\n      },\n      vendorConsentsCallback: function (consentResponse) {\n        cmpResponse.getVendorConsents = consentResponse;\n        afterEach();\n      }\n    }\n  }\n\n  let v1CallbackHandler = handleV1CmpResponseCallbacks();\n  let cmpCallbacks = {};\n  let { cmpFrame, cmpFunction } = findCMP();\n\n  if (!cmpFrame) {\n    return onError('CMP not found.');\n  }\n  // to collect the consent information from the user, we perform two calls to the CMP in parallel:\n  // first to collect the user's consent choices represented in an encoded string (via getConsentData)\n  // second to collect the user's full unparsed consent information (via getVendorConsents)\n\n  // the following code also determines where the CMP is located and uses the proper workflow to communicate with it:\n  // check to see if CMP is found on the same window level as prebid and call it directly if so\n  // check to see if prebid is in a safeframe (with CMP support)\n  // else assume prebid may be inside an iframe and use the IAB CMP locator code to see if CMP's located in a higher parent window. this works in cross domain iframes\n  // if the CMP is not found, the iframe function will call the cmpError exit callback to abort the rest of the CMP workflow\n\n  if (isFn(cmpFunction)) {\n    logInfo('Detected CMP API is directly accessible, calling it now...');\n    if (cmpVersion === 1) {\n      cmpFunction('getConsentData', null, v1CallbackHandler.consentDataCallback);\n      cmpFunction('getVendorConsents', null, v1CallbackHandler.vendorConsentsCallback);\n    } else if (cmpVersion === 2) {\n      cmpFunction('addEventListener', cmpVersion, v2CmpResponseCallback);\n    }\n  } else if (cmpVersion === 1 && inASafeFrame() && typeof window.$sf.ext.cmp === 'function') {\n    // this safeframe workflow is only supported with TCF v1 spec; the v2 recommends to use the iframe postMessage route instead (even if you are in a safeframe).\n    logInfo('Detected Prebid.js is encased in a SafeFrame and CMP is registered, calling it now...');\n    callCmpWhileInSafeFrame('getConsentData', v1CallbackHandler.consentDataCallback);\n    callCmpWhileInSafeFrame('getVendorConsents', v1CallbackHandler.vendorConsentsCallback);\n  } else {\n    logInfo('Detected CMP is outside the current iframe where Prebid.js is located, calling it now...');\n    if (cmpVersion === 1) {\n      callCmpWhileInIframe('getConsentData', cmpFrame, v1CallbackHandler.consentDataCallback);\n      callCmpWhileInIframe('getVendorConsents', cmpFrame, v1CallbackHandler.vendorConsentsCallback);\n    } else if (cmpVersion === 2) {\n      callCmpWhileInIframe('addEventListener', cmpFrame, v2CmpResponseCallback);\n    }\n  }\n\n  function inASafeFrame() {\n    return !!(window.$sf && window.$sf.ext);\n  }\n\n  function callCmpWhileInSafeFrame(commandName, callback) {\n    function sfCallback(msgName, data) {\n      if (msgName === 'cmpReturn') {\n        let responseObj = (commandName === 'getConsentData') ? data.vendorConsentData : data.vendorConsents;\n        callback(responseObj);\n      }\n    }\n\n    window.$sf.ext.register(width, height, sfCallback);\n    window.$sf.ext.cmp(commandName);\n  }\n\n  function callCmpWhileInIframe(commandName, cmpFrame, moduleCallback) {\n    let apiName = (cmpVersion === 2) ? '__tcfapi' : '__cmp';\n\n    let callName = `${apiName}Call`;\n\n    /* Setup up a __cmp function to do the postMessage and stash the callback.\n    This function behaves (from the caller's perspective identicially to the in-frame __cmp call */\n    if (cmpVersion === 2) {\n      window[apiName] = function (cmd, cmpVersion, callback, arg) {\n        let callId = Math.random() + '';\n        let msg = {\n          [callName]: {\n            command: cmd,\n            version: cmpVersion,\n            parameter: arg,\n            callId: callId\n          }\n        };\n\n        cmpCallbacks[callId] = callback;\n        cmpFrame.postMessage(msg, '*');\n      }\n\n      /** when we get the return message, call the stashed callback */\n      window.addEventListener('message', readPostMessageResponse, false);\n\n      // call CMP\n      window[apiName](commandName, cmpVersion, moduleCallback);\n    } else {\n      window[apiName] = function (cmd, arg, callback) {\n        let callId = Math.random() + '';\n        let msg = {\n          [callName]: {\n            command: cmd,\n            parameter: arg,\n            callId: callId\n          }\n        };\n\n        cmpCallbacks[callId] = callback;\n        cmpFrame.postMessage(msg, '*');\n      }\n\n      /** when we get the return message, call the stashed callback */\n      window.addEventListener('message', readPostMessageResponse, false);\n\n      // call CMP\n      window[apiName](commandName, undefined, moduleCallback);\n    }\n\n    function readPostMessageResponse(event) {\n      let cmpDataPkgName = `${apiName}Return`;\n      let json = (typeof event.data === 'string' && includes(event.data, cmpDataPkgName)) ? JSON.parse(event.data) : event.data;\n      if (json[cmpDataPkgName] && json[cmpDataPkgName].callId) {\n        let payload = json[cmpDataPkgName];\n        // TODO - clean up this logic (move listeners?); we have duplicate messages responses because 2 eventlisteners are active from the 2 cmp requests running in parallel\n        if (typeof cmpCallbacks[payload.callId] !== 'undefined') {\n          cmpCallbacks[payload.callId](payload.returnValue, payload.success);\n        }\n      }\n    }\n  }\n}\n\n/**\n * Look up consent data and store it in the `consentData` global as well as `adapterManager.js`' gdprDataHandler.\n *\n * @param cb A callback that takes: a boolean that is true if the auction should be canceled; an error message and extra\n * error arguments that will be undefined if there's no error.\n * @param width if we are running in an iframe, the TCFv1 spec requires us to use the SafeFrame API to find the CMP - which\n * in turn requires width and height.\n * @param height see width above\n */\nfunction loadConsentData(cb, width = 1, height = 1) {\n  let isDone = false;\n  let timer = null;\n\n  function done(consentData, shouldCancelAuction, errMsg, ...extraArgs) {\n    if (timer != null) {\n      clearTimeout(timer);\n    }\n    isDone = true;\n    gdprDataHandler.setConsentData(consentData);\n    if (cb != null) {\n      cb(shouldCancelAuction, errMsg, ...extraArgs);\n    }\n  }\n\n  if (!includes(Object.keys(cmpCallMap), userCMP)) {\n    done(null, false, `CMP framework (${userCMP}) is not a supported framework.  Aborting consentManagement module and resuming auction.`);\n    return;\n  }\n\n  const callbacks = {\n    onSuccess: (data) => done(data, false),\n    onError: function (msg, ...extraArgs) {\n      let consentData = null;\n      let shouldCancelAuction = true;\n      if (allowAuction.value && cmpVersion === 1) {\n        // still set the consentData to undefined when there is a problem as per config options\n        consentData = storeConsentData(undefined);\n        shouldCancelAuction = false;\n      }\n      done(consentData, shouldCancelAuction, msg, ...extraArgs);\n    }\n  }\n  cmpCallMap[userCMP]({\n    width,\n    height,\n    ...callbacks\n  });\n\n  if (!isDone) {\n    if (consentTimeout === 0) {\n      processCmpData(undefined, callbacks);\n    } else {\n      timer = setTimeout(function () {\n        if (cmpVersion === 2) {\n          // for TCFv2, we allow the auction to continue on timeout\n          done(storeConsentData(undefined), false, `No response from CMP, continuing auction...`)\n        } else {\n          callbacks.onError('CMP workflow exceeded timeout threshold.');\n        }\n      }, consentTimeout);\n    }\n  }\n}\n\n/**\n * If consentManagement module is enabled (ie included in setConfig), this hook function will attempt to fetch the\n * user's encoded consent string from the supported CMP.  Once obtained, the module will store this\n * data as part of a gdprConsent object which gets transferred to adapterManager's gdprDataHandler object.\n * This information is later added into the bidRequest object for any supported adapters to read/pass along to their system.\n * @param {object} reqBidsConfigObj required; This is the same param that's used in pbjs.requestBids.\n * @param {function} fn required; The next function in the chain, used by hook.js\n */\nexport function requestBidsHook(fn, reqBidsConfigObj) {\n  const load = (() => {\n    if (consentData) {\n      logInfo('User consent information already known.  Pulling internally stored information...');\n      return function (cb) {\n        // eslint-disable-next-line standard/no-callback-literal\n        cb(false);\n      }\n    } else {\n      // find sizes from adUnits object\n      let adUnits = reqBidsConfigObj.adUnits || $$PREBID_GLOBAL$$.adUnits;\n      let width = 1;\n      let height = 1;\n      if (Array.isArray(adUnits) && adUnits.length > 0) {\n        let sizes = getAdUnitSizes(adUnits[0]);\n        width = sizes[0][0];\n        height = sizes[0][1];\n      }\n\n      return function (cb) {\n        loadConsentData(cb, width, height);\n      }\n    }\n  })();\n\n  load(function (shouldCancelAuction, errMsg, ...extraArgs) {\n    if (errMsg) {\n      let log = logWarn;\n      if (cmpVersion === 1 && !shouldCancelAuction) {\n        errMsg = `${errMsg} 'allowAuctionWithoutConsent' activated.`;\n      } else if (shouldCancelAuction) {\n        log = logError;\n        errMsg = `${errMsg} Canceling auction as per consentManagement config.`;\n      }\n      log(errMsg, ...extraArgs);\n    }\n\n    if (shouldCancelAuction) {\n      if (typeof reqBidsConfigObj.bidsBackHandler === 'function') {\n        reqBidsConfigObj.bidsBackHandler();\n      } else {\n        logError('Error executing bidsBackHandler');\n      }\n    } else {\n      fn.call(this, reqBidsConfigObj);\n    }\n  });\n}\n\n/**\n * This function checks the consent data provided by CMP to ensure it's in an expected state.\n * If it's bad, we call `onError`\n * If it's good, then we store the value and call `onSuccess`\n */\nfunction processCmpData(consentObject, {onSuccess, onError}) {\n  function checkV1Data(consentObject) {\n    let gdprApplies = consentObject && consentObject.getConsentData && consentObject.getConsentData.gdprApplies;\n    return !!(\n      (typeof gdprApplies !== 'boolean') ||\n      (gdprApplies === true &&\n        !(isStr(consentObject.getConsentData.consentData) &&\n          isPlainObject(consentObject.getVendorConsents) &&\n          Object.keys(consentObject.getVendorConsents).length > 1\n        )\n      )\n    );\n  }\n\n  function checkV2Data() {\n    // if CMP does not respond with a gdprApplies boolean, use defaultGdprScope (gdprScope)\n    let gdprApplies = consentObject && typeof consentObject.gdprApplies === 'boolean' ? consentObject.gdprApplies : gdprScope;\n    let tcString = consentObject && consentObject.tcString;\n    return !!(\n      (typeof gdprApplies !== 'boolean') ||\n      (gdprApplies === true && !isStr(tcString))\n    );\n  }\n\n  // do extra things for static config\n  if (userCMP === 'static') {\n    cmpVersion = (consentObject.getConsentData) ? 1 : (consentObject.getTCData) ? 2 : 0;\n    // remove extra layer in static v2 data object so it matches normal v2 CMP object for processing step\n    if (cmpVersion === 2) {\n      consentObject = consentObject.getTCData;\n    }\n  }\n\n  // determine which set of checks to run based on cmpVersion\n  let checkFn = (cmpVersion === 1) ? checkV1Data : (cmpVersion === 2) ? checkV2Data : null;\n\n  if (isFn(checkFn)) {\n    if (checkFn(consentObject)) {\n      onError(`CMP returned unexpected value during lookup process.`, consentObject);\n    } else {\n      onSuccess(storeConsentData(consentObject));\n    }\n  } else {\n    onError('Unable to derive CMP version to process data.  Consent object does not conform to TCF v1 or v2 specs.', consentObject);\n  }\n}\n\n/**\n * Stores CMP data locally in module to make information available in adaptermanager.js for later in the auction\n * @param {object} cmpConsentObject required; an object representing user's consent choices (can be undefined in certain use-cases for this function only)\n */\nfunction storeConsentData(cmpConsentObject) {\n  if (cmpVersion === 1) {\n    consentData = {\n      consentString: (cmpConsentObject) ? cmpConsentObject.getConsentData.consentData : undefined,\n      vendorData: (cmpConsentObject) ? cmpConsentObject.getVendorConsents : undefined,\n      gdprApplies: (cmpConsentObject) ? cmpConsentObject.getConsentData.gdprApplies : gdprScope\n    };\n  } else {\n    consentData = {\n      consentString: (cmpConsentObject) ? cmpConsentObject.tcString : undefined,\n      vendorData: (cmpConsentObject) || undefined,\n      gdprApplies: cmpConsentObject && typeof cmpConsentObject.gdprApplies === 'boolean' ? cmpConsentObject.gdprApplies : gdprScope\n    };\n    if (cmpConsentObject && cmpConsentObject.addtlConsent && isStr(cmpConsentObject.addtlConsent)) {\n      consentData.addtlConsent = cmpConsentObject.addtlConsent;\n    };\n  }\n  consentData.apiVersion = cmpVersion;\n  return consentData;\n}\n\n/**\n * Simply resets the module's consentData variable back to undefined, mainly for testing purposes\n */\nexport function resetConsentData() {\n  consentData = undefined;\n  userCMP = undefined;\n  cmpVersion = 0;\n  gdprDataHandler.reset();\n}\n\n/**\n * A configuration function that initializes some module variables, as well as add a hook into the requestBids function\n * @param {{cmp:string, timeout:number, allowAuctionWithoutConsent:boolean, defaultGdprScope:boolean}} config required; consentManagement module config settings; cmp (string), timeout (int), allowAuctionWithoutConsent (boolean)\n */\nexport function setConsentConfig(config) {\n  // if `config.gdpr` or `config.usp` exist, assume new config format.\n  // else for backward compatability, just use `config`\n  config = config && (config.gdpr || config.usp ? config.gdpr : config);\n  if (!config || typeof config !== 'object') {\n    logWarn('consentManagement config not defined, exiting consent manager');\n    return;\n  }\n  if (isStr(config.cmpApi)) {\n    userCMP = config.cmpApi;\n  } else {\n    userCMP = DEFAULT_CMP;\n    logInfo(`consentManagement config did not specify cmp.  Using system default setting (${DEFAULT_CMP}).`);\n  }\n\n  if (isNumber(config.timeout)) {\n    consentTimeout = config.timeout;\n  } else {\n    consentTimeout = DEFAULT_CONSENT_TIMEOUT;\n    logInfo(`consentManagement config did not specify timeout.  Using system default setting (${DEFAULT_CONSENT_TIMEOUT}).`);\n  }\n\n  if (typeof config.allowAuctionWithoutConsent === 'boolean') {\n    allowAuction.value = config.allowAuctionWithoutConsent;\n    allowAuction.definedInConfig = true;\n  }\n\n  // if true, then gdprApplies should be set to true\n  gdprScope = config.defaultGdprScope === true;\n\n  logInfo('consentManagement module has been activated...');\n\n  if (userCMP === 'static') {\n    if (isPlainObject(config.consentData)) {\n      staticConsentData = config.consentData;\n      consentTimeout = 0;\n    } else {\n      logError(`consentManagement config with cmpApi: 'static' did not specify consentData. No consents will be available to adapters.`);\n    }\n  }\n  if (!addedConsentHook) {\n    $$PREBID_GLOBAL$$.requestBids.before(requestBidsHook, 50);\n  }\n  addedConsentHook = true;\n  gdprDataHandler.enable();\n  loadConsentData(); // immediately look up consent data to make it available without requiring an auction\n\n  // Raise deprecation warning if 'allowAuctionWithoutConsent' is used with TCF 2.\n  if (allowAuction.definedInConfig && cmpVersion === 2) {\n    logWarn(`'allowAuctionWithoutConsent' ignored for TCF 2`);\n  } else if (!allowAuction.definedInConfig && cmpVersion === 1) {\n    logInfo(`'allowAuctionWithoutConsent' using system default: (${DEFAULT_ALLOW_AUCTION_WO_CONSENT}).`);\n  }\n}\nconfig.getConfig('consentManagement', config => setConsentConfig(config.consentManagement));\n"],"names":["userCMP","consentTimeout","gdprScope","staticConsentData","consentData","allowAuction","value","definedInConfig","cmpVersion","addedConsentHook","cmpCallMap","onSuccess","onError","width","height","v2CmpResponseCallback","tcfData","success","logInfo","gdprApplies","eventStatus","processCmpData","v1CallbackHandler","cmpResponse","afterEach","getConsentData","getVendorConsents","consentDataCallback","consentResponse","vendorConsentsCallback","handleV1CmpResponseCallbacks","cmpCallbacks","cmpFrame","cmpFunction","f","window","__tcfapi","__cmp","e","frames","top","parent","findCMP","callCmpWhileInSafeFrame","commandName","callback","$sf","ext","register","msgName","data","responseObj","vendorConsentData","vendorConsents","cmp","callCmpWhileInIframe","moduleCallback","apiName","callName","readPostMessageResponse","event","cmpDataPkgName","json","includes","JSON","parse","callId","payload","returnValue","cmd","arg","Math","random","msg","command","version","parameter","postMessage","addEventListener","undefined","isFn","loadConsentData","cb","isDone","timer","done","shouldCancelAuction","errMsg","clearTimeout","gdprDataHandler","extraArgs","Object","keys","callbacks","storeConsentData","setTimeout","requestBidsHook","fn","reqBidsConfigObj","adUnits","Array","isArray","length","sizes","getAdUnitSizes","load","log","logWarn","logError","bidsBackHandler","call","this","consentObject","getTCData","checkFn","isStr","isPlainObject","tcString","cmpConsentObject","consentString","vendorData","addtlConsent","apiVersion","config","gdpr","usp","cmpApi","isNumber","timeout","allowAuctionWithoutConsent","defaultGdprScope","requestBids","before","setConsentConfig","consentManagement","pbjs","installedModules","push"],"sourceRoot":""}